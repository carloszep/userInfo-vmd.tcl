#|-userInfo.tcl library :
#|  -description :
#|    -tcl scripts library to manage VMD trajectories from MD simulations .
#|    -assists in incorporating user-specified information from simulations .
#|    -this library derived from library anMD.tcl v-0.5.5 :
#|      -userInfo retains all trajInfo, selInfo, and molInfo managing procs .
#|      -anMD library will continue gathering MD trajectory analysis procs .
#|    -this library is related to the freepascal mmLogInfo program
#|     _ that generates trajInfo files from NAMD simulation output ;
#|  -objectives :
#|    -to simplify (further) and to extend structural analyses in VMD .
#|    -to allow the user to incorporate more information to analyses and plots .
#|    -to provide text-based tools to perform analysis remotely :
#|      -decreases dependence on the GUI .
#|      -allows more advanced scripting capabilities ;
#|    -to improve the managing of big trajectories .
#|    -to extend the usability of VMD to other types of modeling results :
#|      -i.e. conformational searches, collections of molecules, databases ;
#|    -to be the base for an even more simplified GUI ;
#|  -author :-Carlos Z. Gómez Castro;
#|  -date :-2018-07-25.Tue ;
#|  -version :-0.0.5 ;
#|  -version information :
#|    -notes :
#|      -requires the use of trajInfo_* files generated by the mmLogInfo
#|       _ program version 0.1.5 or later .
#|      -has to be tested to ensure that the last fragment, wich has simName
#|       _ different from the global simName (sim folder), is well interpreted ;
#|    -changes/updates done :
#|      -updates for the use of trajInfo files generated by the program
#|       _ mmLogInfo version 0.1.5 :
#|        -trajLoad now considers the loadStep specified by the trajInfo array
#|         _ (global), the trajFrag default, or a user-specified value .
#|        -showTrajInfo updated to report the global default loadStep .
#|        -getSelInfo now returns 'trajInfo' in the variable corresponding
#|         _ to the loadStep as default (instead of 'trajFrag') ;;
#|    -finished version ;
#|  -to do in future versions :
#|    -to change the default loadStep value in proc 'trajLoad' .
#|    -to write a proc equivalent to getTrajProp for selInfo .
#|    -to print more help or usage examples in the introduction .
#|    -to consider incorporating the molInfo library .
#|    -to consider rewriting the library in namespace scheme .
#|    -to improve the managing of output/log information reported .
#|    -see also to do list in file anMD055.tcl ;
#|  -declarations and definitions :
#|    -global variables :
#|      -userInfo_version :-script version in format #.#.# ;;;;
#|      -userInfo_logFileName :-default file name for log output ;
#|      -selInfo... :| (this has to be documented in detail)
#|        -array storing information related to atom selections .
#|        -format :
#|          -'selInfo(<selId>,<keys>)' :
#|            -<keys> :
#|              -'selTxt' .
#|              -'molId' .
#|              -'fragId' .
#|              -'first' .
#|              -'last' .
#|              -'frame' .
#|              -'step' .
#|              -'updateSel' .
#|              -'loadStep' .
#|              -'desc' .
#|              -'label' ;;;;
#|      -trajInfo... :| (this has to be documented in detail)
#|        -array storing information about the trajectories loaded in VMD .
#|        -format :
#|          -'trajInfo(<vmd molId>,<keys>)' :
#|            -<keys> :- ;;;;
#|      -molInfo... :- ;| (this has to be documented in detail)
#|      -maxTrajSizeGB :-Maximum traj size according to the available memory ;
#|      -currTrajSize :-sum of the traj sizes loaded into VMD ;
#|      -trajFragList :-model for trajFrag list .
#|        -defines the order and the names identifying each element .
#|        -the array ind is used to map each element according to the position .
#|        -this must correspond to the trajInfo definitions made by
#|         _ program mmLogInfo.pp used to create trajInfo scripts ;
#|      -ind :
#|        -array storing the position indices associated to each element of a
#|         _ trajectory fragment (trajFrag) list .
#|        -array keys (names) are the elements of trajFragList ;;
#|    -procedures and functions :
#|      -trajFragSpec :-decodes fragId specificiations into fragNames ;
#|      -trajLoad :-loads traj coords considering trajInfo ;
#|      -trajDelete :-remove the traj coordinates from memory ;
#|      -trajInfoDelete :-remove traj coords, structure, and selections ;
#|      -showTrajInfo :-prints all the information of a trajectory ;
#|      -getTrajProp :-return specific properties from trajectories ;
#|      -setSelId :-declares atom selections for a trajectory (selIds) ;
#|      -showSelInfo :-prints all the information from a selection (selId) ;
#|      -getSelInfo :-assignates to a set of local variables the information
#|       _ stored in the selInfo array ;
#|      -trajSelId (namespace)... :
#|        -iterate :-used in a while loop to iterate over traj frames ;
#|        -init :-initializes usage of iterate proc ;
#|        -finish :-finalizes usage of an iterate cycle ;
#|        -getFrame :-returns the current frame inside the iteration loop ;
#|        -getDatX :-returns the frame number or the corresponding simulation
#|         _ time of the current frame in the iterate loop ;;
#|      -simTime :-time in ns of a specific frame in a trajectory ;
#|      -simFrame :-frame number correspondig a specific time in a trajectory ;
#|      -simFrag :-returns the fragName containing a specific sim time ;;;
#|  -specific incformation for each procedure :



# constants, global and default parameters
global userInfo_version userInfo_logFileName maxTrajSizeGB
global currTrajSize ind trajFragList selInfo
set userInfo_version 0.0.5
set userInfo_logFileName "log-userInfo-v.$userInfo_version.txt"
set maxTrajSizeGB 5.0
if {![info exists currTrajSize]} {set currTrajSize 0.0}

set selInfo(prot,selTxt) "protein"
set selInfo(pnoh,selTxt) "protein and noh"
set selInfo(CA,selTxt) "protein and name CA"
set selInfo(HBd,selTxt) "(within 1.2 of hydrogen) and (oxygen or nitrogen or sulfur)"
set selInfo(HBa,selTxt) "oxygen or nitrogen or sulfur"

# model list for the trajFrag (trajectory fragment) information
set trajFragList [list fragName simName dcdFile timeStep dcdFreq \
               loadStep dcdSize iniTime finTime iniFrame finFrame frameTime]
# indices for each of the elements of a trajFrag list
set i 0
foreach elem $trajFragList {
  set ind($elem) $i
  incr i
  }



# +++ showing introduction +++

puts -nonewline "\nuserInfo-v.$userInfo_version: "
puts "tcl library to manage VMD trajectories from MD simulations."
puts "  Carlos Z. Gómez Castro, 2010-2018."
puts "Usage:"
puts " 1. source the simulation-specific trajInfo tcl script."
puts " 2. set the array selInfo for each atoms selections to be used."
puts "\nSetting up some default selections in array selInfo..."
foreach key [array names selInfo] {
  puts " $key\t$selInfo($key)"
  }


# +++ structure, trajectory and atom selection managment procedures +++


#|-proc trajFragSpec {l_fragId {id "top"} args} :
#|  -interpreter for user-defined trajectory fragment specifications (fragId) .
#|  -returns a valid specification of trajectory fragments for a molecule Id :
#|    -the specification is a sublist of fragNames refering to particular
#|     _ elements of the full trajFrag list stored in the trajInfo array .
#|    -the returned list will be correctly sorted with no repeated elements ;
#|  -returns an empty string if the fragId specification is not valid .
#|  -the fragIds included in the "exclude" list as well as the unrecognized
#|   _ fragIds will be excluded from the returned list .
#|  -arguments :
#|    -l_fragId :-list of user-provided traj fragment specifications .
#|      -acceptable values in the list :
#|        -list of fragNames or simNames :
#|          -each refer to names at positions 0 and 1 of the trajFrag lists
#|           _ in the trajInfo array ;
#|        -"all" :-a list with all the fragNames is returned .
#|          -all fragments in the trajFrag list are specified ;
#|        -"name" :-the trajInfo(id,name) value will be considered .
#|          -generally will consider the fragments for the last production sim ;
#|        -"first" :-the frag in position 0 of the trajFrag list is specified ;
#|        -"end", "last" :-the last traj fragment is specified ;
#|        -"end-<n>" :-the fragment at position last minus n is specified ;
#|        -"<fragId> to <fragId>", "<fragId> - <fragId>" :
#|          -range of consecutive elements ;
#|        -"exclude", "except", "excl", "exFragId" :
#|          -keyword to include the exclude list in the same fragId spec .
#|          -fragIds after the keyword will be considered as an exclude list .
#|          -overrides the "exclude" argument .
#|          -in the position 0 of the l_fragId specification (as first fragId)
#|           _ will exclude subsequent fragIds from the "all" specification ;
#|        -an integer refering to the fragment position in the trajFrag list ;;
#|    -id :-VMD mol Id pointing to a particular trajInfo array element .
#|      -acceptable values :-"top" :-VMD's current top molecule is used ;;
#|      -default value :-"top" ;;
#|    -args (variable arguments) :
#|      -exlude, except :
#|        -list of fragIds to be excluded from the fragment specification .
#|        -acceptable values :
#|          -the same as l_fragId except for "all" and "exclude" keywords ;;
#|      -loSt, channelIdi, log :-output stream for log messages .
#|        -default value :-stdout ;;;;;;
proc trajFragSpec {l_fragId {id "top"} args} {
# global variables
  global trajInfo ind
# default values for variables and arguments
  set loSt stdout; set exclude {}
  if {$id == "top"} {set id [molinfo top]}
  if {$id == -1} {puts $loSt "trajFragSpec: No trajInfo loaded."; return ""}
# decode variable arguments
  if {[expr {[llength $args]%2}] == 0} {   ;# even or 0 optional arguments
    if {[llength $args] > 0} {
      foreach {arg val} $args {
        switch $arg {
          "exclude" - "except" - "excl" - "exFragId" {set exclude $val}
          "loSt" -  "channelId" - "log" {set loSt $val}
          default {puts $loSt "trajFragSpec: argument unkown: $arg"}
          }
        }
      }
    } else {   ;# odd number of arguments
      puts $loSt "trajFragSpec: Odd number of optional arguments! args: $args"
      return ""
      }
# checks for "exclude" keywords
  set pos -1
  if {[lsearch $l_fragId "exclude"] >= 0} {
    set pos [lsearch $l_fragId "exclude"]
  } elseif {[lsearch $l_fragId "except"] >= 0} {
    set pos [lsearch $l_fragId "except"]
  } elseif {[lsearch $l_fragId "excl"] >= 0} {
    set pos [lsearch $l_fragId "excl"]
  } elseif {[lsearch $l_fragId "exFragId"] >= 0} {
    set pos [lsearch $l_fragId "exFragId"]
    }
  if {$pos == 0} {
    set exclude [lrange $l_fragId 1 end]
    set l_fragId "all"
  } elseif {$pos > 0} {
    set exclude [lrange $l_fragId [expr {$pos + 1}] end]
    set l_fragId [lrange $l_fragId 0 [expr {$pos - 1}]]
    }
#  puts $loSt "\ntrajFragSpec: user fragId: $l_fragId"
#  if {$exclude != {}} {puts $loSt "trajFragSpec: user exclude list: $exclude"}
# build up fragNamesTmp, simNamesTmp, and namesTmp lists
  set fragNamesTmp {}
  set simNamesTmp {}
  set namesTmp {}
  for {set tfi 0} {$tfi < [llength $trajInfo($id,trajFrag)]} {incr tfi} {
    set l_trajFrag [lindex $trajInfo($id,trajFrag) $tfi]
    lappend fragNamesTmp [lindex $l_trajFrag $ind(fragName)]
    lappend simNamesTmp [lindex $l_trajFrag $ind(simName)]
    if {($trajInfo($id,name) == [lindex $l_trajFrag $ind(fragName)]) || \
        ($trajInfo($id,name) == [lindex $l_trajFrag $ind(simName)])} {
        lappend namesTmp [lindex $l_trajFrag $ind(fragName)]
      }
    }
# decode exclude list into fragNames
  set l_fragNameEx {}
  foreach excl $exclude {
    if {$excl == "name"} {
      set l_fragNameEx [concat $l_fragNameEx $namesTmp]
    } elseif {$excl == "first"} {
      lappend l_fragNameEx [lindex [lindex $trajInfo($id,trajFrag) 0] \
                                   $ind(fragName)]
    } elseif {($excl == "last") || ($excl == "end")} {
      lappend l_fragNameEx [lindex [lindex $trajInfo($id,trajFrag) end] \
                                   $ind(fragName)]
    } elseif {($excl == "to") || ($excl == "-")} {
      lappend l_fragNameEx "to"
    } elseif {[string is integer $excl]} {
      if {($excl >= 0) && ($excl < [llength $trajInfo($id,trajFrag)])} {
        lappend l_fragNameEx [lindex [lindex $trajInfo($id,trajFrag) $excl] \
                                     $ind(fragName)]}
    } elseif {[string first "end-" $excl] == 0} {
      lappend l_fragNameEx [lindex [lindex $trajInfo($id,trajFrag) $excl] \
                                   $ind(fragName)]
    } elseif {[lsearch $simNamesTmp $excl] >= 0} {
# no keyword used, then checks for a simName specified in excl
      for {set isn 0} {$isn < [llength $simNamesTmp]} {incr isn} {
        if {[lindex $simNamesTmp $isn] == $excl} {
          lappend l_fragNameEx [lindex $fragNamesTmp $isn]
          }
        }
    } else {
# otherwise a fragName is assumed
      lappend l_fragNameEx $excl
      }
    }
# check for ranges with the "to" keyword for excluded fragIds
  set pos [lsearch $l_fragNameEx "to"]
  while {$pos >= 0} {
# positions for the starting and final range elements in the full list of names
    set prevPos [lsearch $namesTmp [lindex $l_fragNameEx [expr {$pos - 1}]]]
    set postPos [lsearch $namesTmp [lindex $l_fragNameEx [expr {$pos + 1}]]]
    set l_fragNameEx [concat [lrange $l_fragNameEx 0 [expr {$pos - 1}]] \
                             [lrange $fragNamesTmp $prevPos $postPos] \
                             [lrange $l_fragNameEx [expr {$pos + 1}] end]]
    set pos [lsearch $l_fragNameEx "to"]
    }
# decode l_fragId list into fragNames
  set l_fragName {}
  foreach fragId $l_fragId {
    if {$fragId == "all"} {
      set l_fragName $fragNamesTmp
      break
    } elseif {$fragId == "name"} {
      set l_fragName [concat $l_fragName $namesTmp]
    } elseif {$fragId == "first"} {
      lappend l_fragName [lindex [lindex $trajInfo($id,trajFrag) 0] \
                                 $ind(fragName)]
    } elseif {($fragId == "last") || ($fragId == "end")} {
      lappend l_fragName [lindex [lindex $trajInfo($id,trajFrag) end] \
                                 $ind(fragName)]
    } elseif {($fragId == "to") || ($fragId == "-")} {
      lappend l_fragName "to"
    } elseif {[string is integer $fragId]} {
      if {($fragId >= 0) && ($fragId < [llength $trajInfo($id,trajFrag)])} {
        lappend l_fragName [lindex [lindex $trajInfo($id,trajFrag) $fragId] \
                                   $ind(fragName)]}
    } elseif {[string first "end-" $fragId] == 0} {
      lappend l_fragName [lindex [lindex $trajInfo($id,trajFrag) $fragId] \
                                 $ind(fragName)]
    } elseif {[lsearch $simNamesTmp $fragId] >= 0} {
# no keyword used, then checks for a simName specified in fragId
      for {set isn 0} {$isn < [llength $simNamesTmp]} {incr isn} {
        if {[lindex $simNamesTmp $isn] == $fragId} {
          lappend l_fragName [lindex $fragNamesTmp $isn]
          }
        }
    } else {
# otherwise a fragName is assumed
      lappend l_fragName $fragId
      }
    }
# check for ranges with the "to" keyword
  set pos [lsearch $l_fragName "to"]
  while {$pos >= 0} {
# positions for the starting and final range elements in the full list of names
    set prevPos [lsearch $fragNamesTmp [lindex $l_fragName [expr {$pos - 1}]]]
    set postPos [lsearch $fragNamesTmp [lindex $l_fragName [expr {$pos + 1}]]]
    set l_fragName [concat [lrange $l_fragName 0 [expr {$pos - 1}]] \
                           [lrange $fragNamesTmp $prevPos $postPos] \
                           [lrange $l_fragName [expr {$pos + 1}] end]]
    set pos [lsearch $l_fragName "to"]
    }
# build final list running over the trajFrag list
  set retList {}
  foreach fragName $fragNamesTmp {
    if {[lsearch $l_fragNameEx $fragName] < 0} {
      if {[lsearch $l_fragName $fragName] >= 0} {
        lappend retList $fragName
        }
      }
    }
  return $retList
  }   ;# trajFragSpec

#|-proc trajLoad {id {l_fragId "name"} args} :
#|  -load the coordinates of a trajectory according to the information
#|   _ stored in the trajInfo array .
#|  -arguments :
#|    -id :
#|      -vmd molecule ID of the molecule corresponding to the trajectory .
#|      -the psf file must be already loaded by means of the trajInfo script
#|       _ specific for the trajectory .
#|      -may be specified as "top" to use the top molecule ;
#|    -l_fragId :
#|      -list of traj fragment specifications (decoded by proc trajFragSpec) .
#|      -acceptable values :-see trajFragSpec procedure ;
#|      -default value :-"name" ;;
#|    -args (variable arguments) :
#|      -"loadStepUsr", "loadStep", "loadstep", "loadFreq", "stride" :
#|        -frequency for loading frames from the dcd file .
#|        -acceptable values :
#|          -"trajFrag" :
#|            -loadStep value specified in the trajFrag lists is used .
#|            -this value is defaulted in trajInfo_* script files .
#|            -this value is convenient to process the traj fragments
#|             _ sequentially, i.e. to analyze each fragment one at a time ;
#|          -"trajInfo", "global" :
#|            -uses the value stored in trajInfo(<id>,loadStep) .
#|            -this value is defaulted in trajInfo_* script files .
#|            -this value is convenient to fit the whole trajectory in
#|             _ available RAM ;
#|          -a positive integer (excluding zero), i.e. 1, 2, ... ;
#|        -default value :-"trajInfo" ;
#|        -trajectory size is divided by this number, so for big trajectories a
#|         _ larger value may avoid memory overflow ;
#|      -exclude, except :-fragId exclude list for the trajFragSpec proc .
#|        -default value :-{} ;;
#|      -loSt, channelId, log :-output stream for log messages .
#|        -default value :-stdout ;;;;
#|  -notes :
#|    -each fragment coordinates are to be appended to the molecule .
#|    -it is up to the user to load the fragments in a correct order .
#|    -it is recomended to use trajDelete before loading small or
#|     _ non-contiguous fragments ;;
proc trajLoad {id {l_fragId "name"} args} {
  global trajInfo ind maxTrajSizeGB currTrajSize
  global trajFragList
# default values for optional arguments
  set loSt stdout; set exclude {}; set loadStepUsr "trajInfo"
  if {$id == "top"} {set id [molinfo top]}
  if {$id == -1} {puts $loSt "No trajInfo loaded."; return}
# decode variable arguments
  if {[expr {[llength $args]%2}] == 0} {   ;# even or 0 optional arguments
    if {[llength $args] > 0} {
      foreach {arg val} $args {
        switch $arg {
          "loadStepUsr" - "loadStep" - "loadstep" - "loadFreq" - "stride" {
            set loadStepUsr $val
            }
          "exclude" - "except" {set exclude $val}
          "loSt" -  "channelId" - "log" {set loSt $val}
          default {puts $loSt "trajLoad: argument unkown: $arg"}
          }
        }
      }
    } else {   ;# odd number of arguments
      puts $loSt "trajLoad: Odd number of optional arguments! args: $args"
      return ""
      }
  set l_fragId [trajFragSpec $l_fragId $id exclude $exclude loSt $loSt]
  puts $loSt "\nLoading traj coordinates: id: $id name: $trajInfo($id,name)"
#  puts $loSt "  $trajInfo($id,desc)"
  for {set tfi 0} {$tfi < [llength $trajInfo($id,trajFrag)]} {incr tfi} {
    set l_trajFrag [lindex $trajInfo($id,trajFrag) $tfi]
# extract and assign values for new variables from the trajFrag list
    foreach elem $trajFragList {set $elem [lindex $l_trajFrag $ind($elem)]}
    if {($loadStepUsr == "trajInfo") || ($loadStepUsr == "global")} {
      set loadStep $trajInfo($id,loadStep)
    } elseif {$loadStepUsr != "trajFrag"} {
      set loadStep $loadStepUsr
      }
    foreach fragId $l_fragId {
      if {($fragName == $fragId)||($simName == $fragId)||($fragId == "all")} {
        puts $loSt "  trajectory fragment: $fragName (simName: $simName)"
        if {$iniFrame != "unk"} {
          puts $loSt "Coordinates of trajectory fragment already loaded"
          break
          }
# checks whether the trajectory will fit in memory
        set trajSize [expr {$dcdSize/$loadStep}]
        set totalSize [expr {$currTrajSize + $trajSize}]
        if {$totalSize > $maxTrajSizeGB} {
          puts $loSt "Not enough memory to load traj with load step: $loadStep"
# NOTE: code for automatically reducing the load step may be included
          return
          }
        if {$timeStep == 0} {
          set dt $dcdFreq} else {set dt [expr {$dcdFreq*$timeStep/1000000.0}]}
#       puts $loSt "Simulation time in fragment: [expr {$finTime-$iniTime+$dt}]"
# load trajectory fragment
        set iniFrame [expr {[molinfo $id get numframes]}]
        puts -nonewline $loSt "  file: $dcdFile loadStep: $loadStep "
        puts -nonewline $loSt "([expr {$finTime-$iniTime+$dt}] ns) "
        mol addfile $dcdFile step $loadStep waitfor all $id
        set currTrajSize $totalSize
        set finFrame [expr {[molinfo $id get numframes] - 1}]
        set loadedFrames [expr {$finFrame - $iniFrame + 1}]
        set frameTime [expr {$dt*$loadStep}]
# updates initial and final frames
#        set finTime [expr {$iniTime + $dt*$loadStep*$loadedFrames}]
# NOTE: the finTime is not changed (in case the last frame was not loaded)
#   only when the trajFrag is deleted partially this would be changed
#   thus, dt has to be calculated based on the dcdFreq and not from the sim time
        set l_trajFrag [lreplace $l_trajFrag $ind(iniFrame) \
                       $ind(frameTime) $iniFrame $finFrame $frameTime]
        set trajInfo($id,trajFrag) [lreplace $trajInfo($id,trajFrag) $tfi \
                                             $tfi $l_trajFrag]
        puts $loSt "frames: $loadedFrames"
        puts $loSt "  Memory used: $currTrajSize of $maxTrajSizeGB GB"
        }
      }
    }
  }


#|-proc trajDelete {id {l_fragId "all"} args} :
#|  -removes traj coordinates from memory for the specified traj fragments .
#|  -arguments :
#|    -id :-VMD molecule ID that is refered in the trajInfo array ;
#|    -l_fragId :-list of traj fragments to load .
#|      -trajectory fragment specification(s) (decoded by proc trajFragSpec) .
#|      -acceptable values :-see trajFragSpec procedure ;
#|      -default value :-"all" ;;
#|    -args (variable arguments) :
#|      -loSt, channelId, log :-output stream for log messages .
#|        -default value :-stdout ;;
#|      -exclude, except :-fragId exclude list for the trajFragSpec proc .
#|        -default value :-{} ;;;;
#|  -notes :
#|    -the trajFrag list is readed in reverse order ;;
proc trajDelete {id {l_fragId "all"} args} {
  global trajInfo ind maxTrajSizeGB currTrajSize
  global trajFragList
# default values for arguments
  set loSt stdout; set exclude {}
  if {$id == "top"} {set id [molinfo top]}
  if {$id == -1} {puts $loSt "trajDelete: No trajInfo loaded."; return}
# decode variable arguments
  if {[expr {[llength $args]%2}] == 0} {   ;# even or 0 optional arguments
    if {[llength $args] > 0} {
      foreach {arg val} $args {
        switch $arg {
          "loSt" -  "channelId" - "log" {set loSt $val}
          "exclude" - "except" {set exclude $val}
          default {puts $loSt "trajDelete: argument unkown: $arg"}
          }
        }
      }
    } else {   ;# odd number of arguments
      puts $loSt "trajDelete: Odd number of optional arguments! args: $args"
      return ""
      }
  set l_fragId [trajFragSpec $l_fragId $id exclude $exclude loSt $loSt]
  if {$l_fragId == "name"} {set l_fragId $trajInfo($id,name)}
  puts $loSt "\nDeleting traj coordinates: Id $id name: $trajInfo($id,name)"
  for {set tfi [expr {[llength $trajInfo($id,trajFrag)] - 1}]} {$tfi >= 0} \
                                                               {incr tfi -1} {
    set l_trajFrag [lindex $trajInfo($id,trajFrag) $tfi]
# extract and assign values for new variables from the trajFrag list
    foreach elem $trajFragList {set $elem [lindex $l_trajFrag $ind($elem)]}
    foreach fragId $l_fragId {
      if {($fragName == $fragId)||($simName == $fragId)||($fragId == "all")} {
        puts $loSt "  trajectory fragment: $fragName (simName: $simName)"
        if {$iniFrame == "unk"} {
          puts $loSt "Coordinates of traj fragment $fragName not loaded"
          continue
        }
        animate delete beg $iniFrame end $finFrame $id
# calcualtes the amount of memory released
        if {$timeStep == 0} {
#          set loadStepUsed [expr {round($frameTime/$dcdFreq)}]
           set loadStepUsed 1
        } else {
          set loadStepUsed \
            [expr {round($frameTime*1000000.0/$dcdFreq/$timeStep)}]}
        set trajSize [expr {$dcdSize/$loadStepUsed}]
        set currTrajSize [expr {$currTrajSize - $trajSize}]
        set framesDeleted [expr {$finFrame - $iniFrame + 1}]
        puts $loSt "  Deleted $framesDeleted frames."
        if {[expr {abs($currTrajSize) < 0.00000001}]} {
          set currTrajSize 0.0
          }
        puts $loSt \
        "  Memory used: $currTrajSize of $maxTrajSizeGB GB"
# deletes the previous frames values and updates the trajFrag list
        set l_trajFrag [lreplace $l_trajFrag $ind(iniFrame) $ind(frameTime) \
                                    "unk" "unk" "unk"]
        set trajInfo($id,trajFrag) [lreplace $trajInfo($id,trajFrag) $tfi \
                                             $tfi $l_trajFrag]
# shift the frame numbers of the fragments after the current just deleted
        for {set tfr 0} {$tfr < [llength $trajInfo($id,trajFrag)]} {incr tfr} {
          set l_trajFragR [lindex $trajInfo($id,trajFrag) $tfr]
          set iniFrameR [lindex $l_trajFragR $ind(iniFrame)]
          set finFrameR [lindex $l_trajFragR $ind(finFrame)]
          if {($iniFrameR != "unk")} {
            if {($iniFrameR > $finFrame)} {
              set l_trajFragR [lreplace $l_trajFragR \
                                        $ind(iniFrame) $ind(finFrame) \
                                        [expr {$iniFrameR - $framesDeleted}] \
                                        [expr {$finFrameR - $framesDeleted}]]
              set trajInfo($id,trajFrag) [lreplace $trajInfo($id,trajFrag) \
                                                   $tfr $tfr $l_trajFragR]
              }
            }
          }
        }
      }
    }
  }   ;# trajDelete

#|-proc trajInfoDelete {id {loSt stdout}} :
#|  -unset all the information associated to a molId in the trajInfo array  .
#|  -the structure and trajectory will also be deleted from VMD .
#|  -arguments :
#|    -id :-VMD mol ID which is refered in the trajInfo array .
#|      -may specified as "top" to use the top molecule ;
#|    -loSt :-output stream for log messages ;;;
proc trajInfoDelete {id {loSt stdout}} {
  global trajInfo selInfo
  if {$id == "top"} {set id [molinfo top]}
  puts $loSt \
    "\nDeleting info, struct and traj of $trajInfo($id,name) (Id: $id)"
  trajDelete $id "all" loSt $loSt
  puts $loSt "Deleting default selections associated to this molecule..."
  puts $loSt "  Original selInfo array keys:"
  puts $loSt "    [array names selInfo]"
  puts $loSt "  Array keys to be deleted:"
  puts $loSt "    [array names selInfo *-m$id,*]"
  array unset selInfo *-m$id,*
  puts $loSt "Deleting trajInfo information associated to this molecule..."
  array unset trajInfo $id,*
  mol delete $id
  puts $loSt "Simulation information, structure and trajectory deleted."
  }

#|-proc showTrajInfo {id {l_fragId "all"} args} :
#|  -reports the information of a trajectory stored in trajInfo array .
#|  -a list of fragName or simName names can be specified to delimit info .
#|  -an optional return value can be choose .
#|  -arguments :
#|    -id :-vmd mol ID associated to the trajectory .
#|      -may be specified as "top" to use the top molecule ;
#|    -l_fragId :
#|      -user trajectory fragment(s) specification .
#|      -acceptable values :-see trajFragSpec procedure ;
#|      -default value :-"all" ;;
#|    -args (variable arguments) :
#|      -loSt, channelId, log :-output stream for log messages .
#|        -default value :-stdout ;;
#|      -"exlude", "except", "excl", "exFragId" :
#|        -fragId exclude list for the trajFragSpec proc .
#|        -default value :-{} ;;;
#|  -notes :
#|    -it could report also the selIds associated to this molId ;;
proc showTrajInfo {id {l_fragId "all"} args} {
  global ind trajInfo trajFragList currTrajSize
  global maxTrajSizeGB
# default values for arguments
  set loSt stdout; set exclude {}; set procName [lindex [info level 0] 0]
# decode variable arguments
  if {[expr {[llength $args]%2}] == 0} {   ;# even or 0 optional arguments
    if {[llength $args] > 0} {
      foreach {arg val} $args {
        switch $arg {
          "loSt" -  "channelId" - "log" {set loSt $val}
          "exclude" - "except" {set exclude $val}
          default {puts $loSt "$procName: argument unkown: $arg"}
          }
        }
      }
    } else {   ;# odd number of arguments
      puts $loSt "$procName: Odd number of variable arguments! args: $args"
      return ""
      }
  if {$id == "top"} {set id [molinfo top]}
  if {$id == -1} {puts $loSt "procName: No trajInfo loaded."; return}
  set l_fragId [trajFragSpec $l_fragId $id exclude $exclude loSt $loSt]
# print information
  puts $loSt "\n+++ Global simulation parameters: +++"
  puts $loSt "  VMD Id: $id"
  puts $loSt "  sim name: $trajInfo($id,name)"
  puts $loSt "  description: $trajInfo($id,desc)" 
  puts $loSt "  psf file: $trajInfo($id,psf)"
  puts $loSt "  total traj size (GB): $trajInfo($id,dcdSize)"
  puts $loSt "  global load step: $trajInfo($id,loadStep)"
  puts $loSt "  frames currently loaded: [molinfo $id get numframes]"
  puts $loSt "  memory used: $currTrajSize of $maxTrajSizeGB GB"
  set nFrag [llength $trajInfo($id,trajFrag)]
  puts $loSt "  total number of trajectory fragments: $nFrag"
  puts -nonewline $loSt "\nfrag:"
  foreach tfli $trajFragList {puts -nonewline $loSt "  $tfli"}
  puts $loSt ""
  set fragIdIniFrame ""
  set fragIdDcdSize 0.0
  set loaded 0
  for {set tfi 0} {$tfi < $nFrag} {incr tfi} {
    set l_trajFrag [lindex $trajInfo($id,trajFrag) $tfi]
# extract and assign values for new variables from the trajFrag list
    foreach elem $trajFragList {set $elem [lindex $l_trajFrag $ind($elem)]}
    foreach fragId $l_fragId {
      if {($fragId == $fragName)||($fragId == $simName)||($fragId == "all")} {
        puts -nonewline $loSt "$tfi"
        foreach fragElem $l_trajFrag {puts -nonewline $loSt "  $fragElem"}
        puts $loSt ""
        if {$iniFrame == "unk"} {break}
        if {$fragIdIniFrame == ""} {
# this is only set the first time a requested fragment was found to be loaded
          set fragIdIniFrame $iniFrame
          set fragIdIniTime $iniTime
          set loaded 1
          }
        set fragIdFinFrame $finFrame
        set fragIdFinTime [simTime $finFrame $id]
# calcualtes the amount of memory released
        set timeStep [lindex $l_trajFrag $ind(timeStep)]
        if {$timeStep == 0} {
           set loadStepUsed 1
        } else {
          set loadStepUsed \
            [expr {round($frameTime*1000000.0/$dcdFreq/$timeStep)}]}
        set fragIdDcdSize \
              [expr {$fragIdDcdSize + $dcdSize/$loadStepUsed}]
        break
        }
      }
    }
# report information only for the specified trajFrags if loaded
  if {$loaded} {
    puts $loSt "\nSimulation parameters for loaded fragment(s)"
    puts $loSt "  iniFrame: $fragIdIniFrame"
    puts $loSt "  finFrame: $fragIdFinFrame"
    puts $loSt "  iniTime (ns): $fragIdIniTime"
    puts $loSt "  finTime (ns): $fragIdFinTime"
    puts $loSt "  accumulated DCD size (GB): $fragIdDcdSize"
    }
  }   ;# showTrajInfo


#|-proc getTrajProp {prop {id "top"} {l_fragId "name"} args} :
#|  -return the value of a specified property stored in the trajFrag lists .
#|  -the returned values may vary depending on the current status of the
#|   _ trajectory, e.g. whether or not the coordinates were loaded .
#|  -arguments :
#|    -prop :-property whose value is returned for the specified trajFrag
#|     _ list(s) .
#|      -acceptable values :
#|        -any element of the trajFragList .
#|        -"fragName", "dcdFile" :
#|          -return a list of the respective data for the number of fragments
#|           _ refered through the l_fragId argument ;
#|        -"simName", "timeStep", "dcdFreq", "loadStep", "frameTime" :
#|          -return a list of values of the property if these are heterogeneous
#|           _ among the matching trajFrag lists refered by the l_fragId arg .
#|          -return a single value of the property if the value is the same for
#|           _ the trajFrag lists refered by the l_fragId argument :
#|            -for these properties the single-structure trajFrag lists are
#|             _ excluded (e.g. same iniTime and finTime) .
#|            -thus, single-structure coordinates may be considered as a part
#|             _ of the subsequent traj fragment (i.e. initial structure) .
#|            -useful for a proc to know whether a set of fragments are part of
#|             _ a single sim set-up or they have heterogeneous sim/min runs ;;
#|        -"dcdSize" :
#|          -return the sum of the dcd sizes considered in the trajFrag lists
#|           _ matching the l_fragId specification ;
#|        -"iniTime" :
#|          -return the iniTime property value from the first trajFrag list
#|           _ matching the specification by the l_fragId argument ;
#|        -"finTime" :
#|          -returns the finTime property value from the last trajFrag list
#|           _ matching the specification by the l_fragId argument ;
#|        -"iniFrame" :
#|          -returns the iniFrame property value from the first loaded trajFrag
#|           _ list matching the l_fragId specification .
#|          -returns "unk" if all the fragFrag lists specifyied by l_fragId
#|           _ were not loaded ;
#|        -"finFrame" :
#|          -returns the finFrame property value from the last loaded trajFrag
#|           _ list matching the l_fragId specification .
#|          -returns "unk" if none of the traj fragments specifyed by l_fragId
#|           _ were no loaded ;
#|        -"numTrajFrag", "numFrag" :
#|          -returns the number of trajFrag lists considered in
#|           _ the l_fragId specification ;
#|        -"listTrajFrag" :
#|          -returns a list of full trajFrag lists containing fragments
#|           _ matching the specification by the l_fragId argument .
#|          -may be used to extract sublists of the trajFrag stored in the
#|           _ trajInfo array ;
#|        -"seqTraj", "seqTime" :
#|          -meaning "are the traj fragments sequential in simulation time?" .
#|          -returns "1" if the list of trajFrags specified by l_fragId have
#|           _ a sequential (growing) trend in time; returns "0" otherwise :
#|            -i.e.: an equilibration sequence would return value of 0 ;;
#|        -"seqFrame", "seqFrames" :
#|          -meaning "are the fragment's frames sequential or consecutive?" .
#|          -returns "1" if the coordinates of the trajFrag lists specified
#|           _ in l_fragId were loaded consecutively and in order .
#|          -returns "0" when the fin and iniFrames between contiguous
#|           _ trajFrags specified by l_trajFrag are not consecutive ;
#|        -"loaded" :
#|          -returns "1" if all trajFrags specified by l_fragId were loaded,
#|           _ returns "0" otherwise ;
#|        -"loadedFrag", "fragLoaded" :
#|          -returns a list of fragNames that are loaded in the fragID spec ;;;
#|    -id :
#|      -acceptable values :
#|        -a VMD molid of a loaded molecule considered in the trajInfo array .
#|        -"top" :-the current top molecule in VMD is used ;;
#|      -default value :-"top" ;;
#|    -l_fragId :
#|      -list of traj fragment specifications (decoded by proc trajFragSpec) .
#|      -acceptable values :-see trajFragSpec procedure ;
#|      -default value :-"name" ;;
#|    -args (variable arguments) :
#|      -loSt, channelId, log :-output stream for log messages .
#|        -default value :-stdout ;;
#|      -exlude, except, excl, exFragId :
#|        -list of fragIds to be excluded from the fragment specification .
#|        -acceptable values :
#|          -the same as l_fragId except for "all", "exclude", and
#|           _ "except" keywords ;;;;
#|  -notes :
#|    -the proc retuns strictly the values stored in the trajFrag lists, so
#|     _ the overrided default properties (i.e. loadStep) may have different
#|     _ values from those actually used .
#|    -usage examples... :- ;;;
proc getTrajProp {prop {id "top"} {l_fragId "name"} args} {
  global ind trajInfo trajFragList
# default values for arguments
  set loSt stdout; set exclude {}
# decode variable arguments
  if {[expr {[llength $args]%2}] == 0} {   ;# even or 0 optional arguments
    if {[llength $args] > 0} {
      foreach {arg val} $args {
        switch $arg {
          "loSt" - "channelId" - "log" {set loSt $val}
          "exclude" - "except" - "excl" - "exFragId" {set exclude $val}
          default {puts $loSt "trajFragSpec: argument unkown: $arg"}
          }
        }
      }
    } else {   ;# odd number of arguments
      puts $loSt "trajFragSpec: Odd number of optional arguments! args: $args"
      return ""
      }
  if {$id == "top"} {set id [molinfo top]}
  if {$id == -1} {puts $loSt "trajDelete: No trajInfo loaded."; return}
  set l_fragId [trajFragSpec $l_fragId $id exclude $exclude loSt $loSt]
# temporal variables to store the value(s) of the property requested
  set l_valProp {}
  set sumValProp 0.0
  set homoValProp ""
  set retValProp ""
  for {set tfi 0} {$tfi < [llength $trajInfo($id,trajFrag)]} {incr tfi} {
    set l_trajFrag [lindex $trajInfo($id,trajFrag) $tfi]
    foreach fragId $l_fragId {
      if {$fragId == [lindex $l_trajFrag $ind(fragName)]} {
# the current trajFrag is included in the l_fragId specification
        switch $prop {
          "fragName" - "dcdFile" {
            lappend l_valProp [lindex $l_trajFrag $ind($prop)]
            set retValProp $l_valProp
            }
          "simName" - "timeStep" - "dcdFreq" - "loadStep" - "frameTime" {
            set valProp [lindex $l_trajFrag $ind($prop)]
            lappend l_valProp $valProp
# exclude the single-structure trajFrags as homoValProp
            if {[lindex $l_trajFrag $ind(iniTime)] != \
                [lindex $l_trajFrag $ind(finTime)]} {
              if {$homoValProp == ""} {
                set homoValProp $valProp
              } else {
                if {$valProp == $homoValProp} {
                  set homoValProp $valProp
                } else {
                  set homoValProp "none"
                  }
                }
              }
# evaluates whether the prop values are homogeneous up to this trajFrag
            if {$homoValProp == "none"} {
              set retValProp $l_valProp
            } else {
              set retValProp $valProp
              }
            }
          "dcdSize" {
            set valProp [lindex $l_trajFrag $ind($prop)]
            set sumValProp [expr {$sumValProp + $valProp}]
            set retValProp $sumValProp
            }
          "iniTime" {return [lindex $l_trajFrag $ind($prop)]}
          "finTime" {set retValProp [lindex $l_trajFrag $ind($prop)]}
          "iniFrame" {
            set valProp [lindex $l_trajFrag $ind($prop)]
            set retValProp $valProp
            if {$valProp != "unk"} {
              return $valProp
              }
            }
          "finFrame" {
            set valProp [lindex $l_trajFrag $ind($prop)]
            if {$retValProp == ""} {
              set retValProp $valProp
            } else {
              if {$valProp != "unk"} {
                set retValProp $valProp
                }
              }
            }
          "numTrajFrag" - "numFrag" {
            if {$retValProp == ""} {set retValProp 1} else {incr retValProp}
            }
          "listTrajFrag" {lappend retValProp $l_trajFrag}
          "seqTraj" - "seqTime" {
            if {$retValProp == ""} {
              set prevFinTime [lindex $l_trajFrag $ind(finTime)]
              if {$prevFinTime == "unk"} {return 0}
              set retValProp 1
            } else {
              if {$prevFinTime >= [lindex $l_trajFrag $ind(iniTime)]} {
                return 0
              } else {
                set prevFinTime [lindex $l_trajFrag $ind(finTime)]
                }
              }
            }
          "seqFrame" - "seqFrames" {
            if {$retValProp == ""} {
              set prevFinFrame [lindex $l_trajFrag $ind(finFrame)]
              if {$prevFinFrame == "unk"} {return 0}
              set retValProp 1
            } else {
              set currIniFrame [lindex $l_trajFrag $ind(iniFrame)]
              if {$currIniFrame == "unk"} {return 0} 
              if {$prevFinFrame != [expr {$currIniFrame - 1}]} {
                return 0
              } else {
                set prevFinFrame [lindex $l_trajFrag $ind(finFrame)]
                }
              }
            }
          "loaded" {
            if {[lindex $l_trajFrag $ind(iniFrame)] == "unk"} {
              return 0} else {set retValProp 1}
            }
          "loadedFrag" - "fragLoaded" {
            if {[lindex $l_trajFrag $ind(iniFrame)] != "unk"} {
              lappend retValProp $fragId
              }
            }
          default {puts "Unknown property! ($prop)"; return ""}
          }
        break
        }
      }
    }
  return $retValProp
  }   ;# getTrajProp


#|-proc setSelId {selIds args} :
#|  -declares an entry for the selInfo array to specify an atom selection
#|   _ information from a trajectory .
#|  -arguments :
#|    -selIds :-list of identificator names used to access or point to
#|     _ paricular elements of the selInfo array (the first index) .
#|      -if the specified selId is already used in the selInfo array the
#|       _ specified elements of the array will be updated (overwritten) .
#|      -acceptable values and keywords :
#|        -list of selId names either new or already used in the selInfo array .
#|        -"unset", "delete" :
#|          -unsets all the array keys including the specified selId .
#|          -a list od selIds is acceptable .
#|          -the second argument is then expected to be the selId(s) to delete .
#|          -usage for this case :-'setSelId unset <l_selId>' ;;;;
#|    -args (variable arguments) :
#|      -"selTxt", "sel", "selection", "atomselect", "atomSel" :
#|        -specify the "selTxt" key in the second index of the selInfo array :
#|          -i.e. selInfo(<selId>,selTxt) .
#|          -specify a selection text for the "atomselect" proc of VMD ;
#|        -acceptable values :
#|          -VMD's atom selection texts (see VMD's user guide) .
#|          -a list of values is acceptable corresponding to each selId
#|           _ specified :
#|            -for a single selection text it may be necessary to enclose in
#|             _ curly braces, i.e. {"protein and name CA"} ;
#|          -a single value common to several selIds specified ;
#|        -default :-if no selTxt is specified the array key is not declared ;;
#|      -"molId", "molid", "id", "ID", "mol", "idMol", "vmdMol", "VMDmol" :
#|        -VMD mol ID, preferently already loaded from a trajInfo script .
#|        -acceptable values :
#|          -an integer number corresponding to a VMD mol ID .
#|          -a list of Ids corresponding to each selId specified .
#|          -a single value common to several selIds specified .
#|          -"top" :-refers to VMD's top molecule ;
#|          -"unset", "delete" :-the array element ("<selId>,molId") is unset ;;
#|        -default :-the array entry is not declared ;;
#|      -"fragId", "frag", "trajFrag", "fragSpec", "simFrag", "fragment",
#|        _ "fragments" :
#|        -list of trajectory fragment specifications .
#|        -acceptable values :
#|          -a valid fragId specification (see "trajFragSpec" procedure) .
#|          -"unset", "delete" :-the selInfo(<selId>,fragId) key is unset ;
#|          -a list of values corresponding to each selId specified .
#|          -a single value common to several selIds specified ;
#|        -default :-the variable (selInfo array entry) will not be set ;;
#|      -"exclude", "except", "excl", "exFragId" :
#|        -fragId specification "exclude" list .
#|        -this exclude specification will be added to fragId spec if it does
#|         _ not includes already any "exclude" keywords, otherwise is ignored .
#|        -acceptable values :
#|          -see "trajFragSpec" procedure .
#|          -a list of values corresponding to each selId specified .
#|          -a single value common to all the specified selIds ;
#|        -default value :-{} ;
#|        -note :-this feature is not functional yet ;;
#|      -"first", "ini", "start", "begin", "iniRange" :
#|        -left-bound (starting) range of the simulation time interval to be
#|         _ considered in the selection (to be used by some analysis procs) .
#|        -specifies the selInfo(<selId>,first) array element .
#|        -acceptable values :
#|          -a real/integer number corresponding to a sim time or frame .
#|          -a list of values corresponding to each selId specified .
#|          -a single value common to several selIds specified .
#|          -"now" :-the current frame is taken as "first" value ;
#|          -"unset", "delete" :
#|            -the selInfo(<selId>,first) array key is unset ;;
#|        -default :-the selInfo(<selId>,first) key will not be set ;;;
#|      -"last", "end", "final", "stop", "until", "finRange" :
#|        -right-bound (ending) range of the simulation time interval to be
#|         _ considered in the selection (to be used by some analysis procs) .
#|        -specifies the selInfo(<selId>,last) array element .
#|        -acceptable values :
#|          -a real/integer number corresponding to a sim time or frame .
#|          -a list of values corresponding to each selId specified .
#|          -a single value common to several selIds specified .
#|          -"now" :-the current frame is taken as "last" value ;
#|          -"unset", "delete" :
#|            -the selInfo(<selId>,last) array key is unset ;;
#|        -default :-the selInfo(<selId>,last) key will not be set ;;
#|      -"frame", "time", "simTime", "current", "currFrame", "currTime" :
#|        -frame/time specification (used for some analysis procedures) .
#|        -it is expected to refer to a simulation time in ns .
#|        -specify the 'selInfo(<selId>,frame)' array element .
#|        -acceptable values :
#|          -real (float) value in ns or an integer for a sim frame .
#|          -a list of values corresponding to each selId specified .
#|          -a single value common to several selIds specified .
#|          -"now" :-refers to the time equivalent to the current frame ;
#|          -"first", "iniTime" :-points to the "iniTime" property of the
#|           _ fragId specification (see "getTrajProp" procedure) ;
#|          -"last", "finTime" :-point to the "finTime" property of the fragId
#|           _ specification (see "getTrajProp" procedure) ;
#|          -"unset", "delete" :
#|            -the selInfo array key ("<selId>,frame") should be unset ;;
#|        -default :-the variable (array entry) will not be set ;;
#|      -"step", "stride", "frameStep", "iterateStep", "sampling" :
#|        -step to be used in an interation loop over the loaded traj frames .
#|        -will affect the duration time and results of some analysis procs .
#|        -specify the 'selInfo(<selId>,step)' array element .
#|        -acceptable values :
#|          -an integer number .
#|          -a list of values corresponding to each selId specified .
#|          -a single value common to several selIds specified .
#|          -"unset", "delete" :-the selInfo(<selId>,step) key will be unset ;;
#|        -default :-the 'selInfo(<selId>,step)' key will not be set ;;
#|      -"updateSel", "update", "updSel", "selUpdate" :
#|        -flag specifying whether the selection has to be updated every frame .
#|        -specify the 'selInfo(<selId>,updateSel)' array element .
#|        -acceptable values :
#|          -"0" :-the selection will not be updated ;
#|          -"1" :-the selection will be updated every frame ;
#|          -a list of values corresponding to each selId specified .
#|          -a single value common to several selIds specified ;
#|        -default :-the 'selInfo(<selId>,updateSel)' key will not be set ;;
#|      -"loadStep", "dcdLoadStep", "trajLoadStep" :
#|        -trajectory (dcd) load step to be used for analysis procs .
#|        -specifies the 'selInfo(<selId>,loadStep)' array element .
#|        -acceptable values :
#|          -a positive integer value .
#|          -a list of values corresponding to each selId specified .
#|          -a single value common to several selIds specified .
#|          -"unset", "delete" :
#|            -the selInfo(<selId>,loadStep) key will be unset ;;
#|        -default :-the 'selInfo(<selId>,loadStep)' key will not be set ;;
#|      -"desc", "description" :
#|        -description text for the selection to be used for analysis procs .
#|        -specified the 'selInfo(<selId>,desc)' array element .
#|        -acceptable values :
#|          -text string .
#|          -a list of values corresponding to each selId specified .
#|          -a single value common to several selIds specified .
#|          -for a single selId the description text may be eclosed in curly
#|           _ braces besides quotation marks, i.e. {"description text"} .
#|          -"unset", "delete" :-the selInfo(<selId>,desc) key will be unset ;;
#|        -default :-the 'selInfo(<selId>,desc)' key will not be set ;;
#|      -"label", "selIdLabel", "selInfoLabel", "lbl", "legend" :
#|        -short string to be used as data set label for graphs .
#|        -specifies the 'selInfo(<selId>,label)' array element .
#|        -acceptable values :
#|          -short string (name) (no blank spaces preferently) .
#|          -a list of values for each selId specified is acceptable .
#|          -a single value common to several selIds specified .
#|          -"unset", "delete" :-the selInfo(<selId>,label) key will be unset ;;
#|        -default :-the 'selInfo(<selId>,label)' key will not be set ;;
#|      -"loSt", "channelId", "log" :-output stream for log messages .
#|        -default value :-stdout ;;
#|      -any other arbitrary token to be used as new user-defined array key .
#|        -specifies array element 'selInfo(<selId>,<newDefKey>)' .
#|        -must be followed by the respective array key value .
#|        -acceptable values :
#|          -general tokens .
#|          -a list of values corresponding to each selId specified .
#|          -a single value common to several selIds specified .
#|          -"unset", "delete" :
#|            -the selInfo(<selId>,<newDefKey>) key will be unset ;;;;;
#|  -notes :
#|    -this proc is intended to ease selId setting up to the user .
#|    -"getSelInfo" proc will still be used to manage default values of selIds
#|     _ by other procedures .
#|    -the exclude lists as arguments independent from the fragIds lists were
#|     _ not implemented, use exclude lists within the fragId specification ;;
proc setSelId {selIds args} {
  global selInfo
# default values for variables
  set loSt stdout; set excl {}; set procName [lindex [info level 0] 0]
  set sel {}; set id {}; set frag {}; set excl {}; set frst {}; set lst {}
  set frm {}; set stp {}; set upd {}; set ldStp {}; set lbl {}; set desc {}
  set delSelId {}; set def {}
# decode variable arguments
  if {[expr {[llength $args]%2}] == 0} {   ;# even or 0 optional arguments
    if {[llength $args] > 0} {
      foreach {arg val} $args {
        switch $arg {
          "selTxt" - "sel" - "selection" - "atomselect" - "atomSel" {
            set sel $val}
          "molId" - "molid" - "Id" - "id" - "ID" - "mol" - "idMol" - \
            "vmdMol" - "VMDmol" {set id $val}
          "fragId" - "frag" - "trajFrag" - "fragSpec" - "simFrag" - \
            "fragment" - "fragments" {set frag $val}
          "first" - "ini" - "start" - "begin" - "iniRange" {set frst $val}
          "last" - "end" - "final" - "stop" - "until" - "finRange" {
            set lst $val}
          "frame" - "time" - "simTime" - "current" - "currFrame" - "currTime" {
            set frm $val}
          "step" - "stride" - "frameStep" - "iterateStep" - "sampling" {
            set stp $val}
          "updateSel" - "update" - "updSel" - "selUpdate" {set upd $val}
          "loadStep" - "dcdLoadStep" - "trajLoadStep" {set ldStp $val}
          "desc" - "description" {set desc $val}
          "label" - "selIdLabel" - "selInfoLabel" - "lbl" - "legend" {
            set lbl $val}
          "loSt" -  "channelId" - "log" {set loSt $val}
          default {
            lappend def $arg
            set $arg $val
            }
          }
        }
      }
    } else {   ;# odd number of arguments
# check for 'unset <selId>' case. selId to delete in the first pos in args
      if {($selIds == "unset") || ($selIds == "delete")} {
        set delSelId [lindex $args 0]
        set args [lrange $args 1 end]
      } else {
        puts $loSt "$procName: Odd number of variable arguments! args: $args"
        return ""}
# allows selecting the loSt when using keyword unset/delete
      foreach {arg val} $args {
        switch $arg {
          "loSt" -  "channelId" - "log" {set loSt $val}
          default {puts $loSt "$procName: argument out of context: $arg"}
          }
        }
      }
# check for 'unset <selId>' case, and return if requested
  if {$delSelId != {}} {
    foreach del $delSelId {
      array unset selInfo $del,*
      puts $loSt "$procName: deleted selId: $del,*"
      }
    return ""
    }
# show info
  puts $loSt "\n$procName: setting up selection Ids for the selInfo array..."
  puts $loSt "  List of selIds: $selIds"
  puts $loSt "  Variable arguments: $args"
  if {$def != {}} {puts $loSt "  Unknown array keys to be defined: $def"}
# analyze input arguments to create lists with the same length as selIds
  set nSel [llength $selIds]
  set lvar [concat [list sel id frag frst lst frm stp upd ldStp desc lbl] \
                   [set def]]
  foreach var $lvar {
    set val [set $var]
    set nArg [llength $val]
    if {$nArg == 1} {
      for {set i 1} {$i < $nSel} {incr i} {lappend $var [lindex $val 0]}
    } elseif {(($nArg > 1) && ($nArg < $nSel)) || ($nArg > $nSel)} {
      puts $loSt "$procName: Incorrect number of values for argument $var"
      return ""
      }
    }
# correct fragIds if exclude lists were specified (NOT IMPLEMENTED YET)
  if {[llength $excl] > 0} {
    puts $loSt \
      "WARNING: exclude lists independent from fragIds not implemented yet!"
    }
# set the specified selInfo array elements
  for {set s 0} {$s < [llength $selIds]} {incr s} {
    set selId [lindex $selIds $s]
    foreach var $lvar {
      set val [set $var]
      if {[llength $val] > 0} {
        set selVal [lindex $val $s]
        switch $var {
          sel {
            puts $loSt "  setting 'selInfo($selId,selTxt)' to '$selVal'"
            set selInfo($selId,selTxt) $selVal
            }
          id {
            if {($selVal == "unset") || ($selVal == "delete")} {
              array unset selInfo $selId,molId
              puts $loSt "  'selInfo($selId,molId)' deleted"
            } else {
              puts $loSt "  setting 'selInfo($selId,molId)' to '$selVal'"
              set selInfo($selId,molId) $selVal
              }
            }
          frag {
            if {($selVal == "unset") || ($selVal == "delete")} {
              array unset selInfo $selId,fragId
              puts $loSt "  'selInfo($selId,fragId)' deleted"
            } else {
              puts $loSt "  setting 'selInfo($selId,fragId)' to '$selVal'"
              set selInfo($selId,fragId) $selVal
              }
            }
          frst {
            if {($selVal == "unset") || ($selVal == "delete")} {
              array unset selInfo $selId,first
              puts $loSt "  'selInfo($selId,first)' deleted"
            } else {
              puts $loSt "  setting 'selInfo($selId,first)' to '$selVal'"
              set selInfo($selId,first) $selVal
              }
            }
          lst {
            if {($selVal == "unset") || ($selVal == "delete")} {
              array unset selInfo $selId,last
              puts $loSt "  'selInfo($selId,last)' deleted"
            } else {
              puts $loSt "  setting 'selInfo($selId,last)' to '$selVal'"
              set selInfo($selId,last) $selVal
              }
            }
          frm {
            if {($selVal == "unset") || ($selVal == "delete")} {
              array unset selInfo $selId,frame
              puts $loSt "  'selInfo($selId,frame)' deleted"
            } else {
              puts $loSt "  setting 'selInfo($selId,frame)' to '$selVal'"
              set selInfo($selId,frame) $selVal
              }
            }
          stp {
            if {($selVal == "unset") || ($selVal == "delete")} {
              array unset selInfo $selId,step
              puts $loSt "  'selInfo($selId,step)' deleted"
            } else {
              puts $loSt "  setting 'selInfo($selId,step)' to '$selVal'"
              set selInfo($selId,step) $selVal
              }
            }
          upd {
            puts $loSt "  setting 'selInfo($selId,updateSel)' to '$selVal'"
            set selInfo($selId,updateSel) $selVal
            }
          ldStp {
            if {($selVal == "unset") || ($selVal == "delete")} {
              array unset selInfo $selId,loadStep
              puts $loSt "  'selInfo($selId,loadStep)' deleted"
            } else {
              puts $loSt "  setting 'selInfo($selId,loadStep)' to '$selVal'"
              set selInfo($selId,loadStep) $selVal
              }
            }
          desc {
            if {($selVal == "unset") || ($selVal == "delete")} {
              array unset selInfo $selId,desc
              puts $loSt "  'selInfo($selId,desc)' deleted"
            } else {
              puts $loSt "  setting 'selInfo($selId,desc)' to '$selVal'"
              set selInfo($selId,desc) $selVal
              }
            }
          lbl {
            if {($selVal == "unset") || ($selVal == "delete")} {
              array unset selInfo $selId,label
              puts $loSt "  'selInfo($selId,label)' deleted"
            } else {
              puts $loSt "  setting 'selInfo($selId,label)' to '$selVal'"
              set selInfo($selId,label) $selVal
              }
            }
          default {
            if {($selVal == "unset") || ($selVal == "delete")} {
              array unset selInfo $selId,$var
              puts $loSt "  'selInfo($selId,$var)' deleted"
            } else {
              puts $loSt "  setting 'selInfo($selId,$var)' to '$selVal'"
              set selInfo($selId,$var) $selVal
              }
            }
          }
        }
      }
    }
  }


#|-proc showSelInfo {selId {loSt stdout}} :
#|  -reports atom selection information stored in the selInfo array .
#|  -arguments :
#|    -selId :-array keys considered to show info ;
#|    -loSt :-optional output stream for log messages .-default is stdout ;;
#|  -Notes :-No error checking is included yet ;;
proc showSelInfo {selId {loSt stdout}} {
  global selInfo
  puts $loSt "\nshowSelInfo: Selection information (selId: $selId)"
  if {[info exists selInfo($selId,selTxt)]} {
      puts $loSt "  Selection text: $selInfo($selId,selTxt)"
      set selTxt $selInfo($selId,selTxt)
    } else {
      puts $loSt "  No selection text specified. Default is 'none'."
      set selTxt "none"
      }
  if {[info exists selInfo($selId,molId)]} {
      puts $loSt "  VMD molecule ID: $selInfo($selId,molId)"
      set molId $selInfo($selId,molId)
    } else {
      puts $loSt "  No molId associated. Default is the 'top' molecule."
      set molId "top"
      }
  if {[info exists selInfo($selId,fragId)]} {
      puts $loSt "  Trajectory fragment (fragId) specification:\
                    $selInfo($selId,fragId)"
      set fragId $selInfo($selId,fragId)
    } else {
      puts $loSt "  No trajectory fragment (fragId) specified.\
                    Default is 'name'."
      set fragId "name"
      }
  if {[info exists selInfo($selId,frame)]} {
      puts $loSt "  Selection frame: $selInfo($selId,frame)"
      set frm $selInfo($selId,frame)
    } else {
      puts $loSt "  No frame specified. Default is the current frame or 'now'."
      set frm "now"
      }
  if {[info exists selInfo($selId,first)]} {
      puts $loSt "  Selection range first frame: $selInfo($selId,first)"
    } else {
      puts $loSt "  No first time specified. Default is obtained from\
                    the fragId specification, or 'first' otherwise."}
  if {[info exists selInfo($selId,last)]} {
      puts $loSt "  Selection range last frame: $selInfo($selId,last)"
    } else {
      puts $loSt "  No last frame specified. Default is obtained from\
                    the fragId specification, or 'last' otherwise."}
  if {[info exists selInfo($selId,step)]} {
      puts $loSt "  Selection range step: $selInfo($selId,step)"
    } else {puts $loSt "  No step specified. Default is 1."}
  if {[info exists selInfo($selId,updateSel)]} {
      if {$selInfo($selId,updateSel)} {
          puts $loSt "  The selection will be updated every frame."
        } else {puts $loSt "  The selection will not be updated every frame."}
    } else {puts $loSt "  The selection will not be updated every frame."}
  if {[info exists selInfo($selId,loadStep)]} {
      puts $loSt "  Load step for the fragId: $selInfo($selId,loadStep)"
    } else {puts $loSt "  No load step specified. Default is 'trajFrag'"}
  if {[info exists selInfo($selId,desc)]} {
      puts $loSt "  Description text for the selId: $selInfo($selId,desc)"
    } else {puts $loSt "  No description text specified. Default is ''"}
  if {[info exists selInfo($selId,label)]} {
      puts $loSt "  Label (legend) specified: $selInfo($selId,label)"
    } else {puts $loSt "  No label specified. Default is the selId, '$selId'"}
  set tempSel [atomselect $molId $selTxt frame $frm]
  puts $loSt "The selection comprises [$tempSel num] atoms."
  $tempSel delete
  }

#|-proc getSelInfo {selId selN idN fragN frmN frstN lstN stpN updN ldstpN
#|                                                            _ lblN descN} :
#|  -extract the selection information associated to a selId and assign the
#|   _ values to the variables selN, idN, fragN frmN, frstN, lstN, stpN,
#|   _ updN, ldstpN, and lblN .
#|  -it will assign default values if the keys have not been specified .
#|  -if the molId specified is already loaded the default values will be set
#|   _ accordingly .
#|  -arguments :
#|    -selId :-selId used as key in the selInfo array ;
#|    -names of the variables used in the calling procedure :
#|      -selN :-selection text variable name .
#|        -default value to return :-'none' ;;
#|      -idN :-VMD mol ID .
#|        -if "top" is specified the top molecule Id will be returned if
#|         _ exists .
#|        -default value to return :
#|          -the current top molecule .
#|          -'top' if no molecule was loaded into VMD ;;
#|      -fragN :-name of the variable with the fragId specification .
#|        -this fragId may be used to determine first and last frames if they
#|         _ are not specified in the selInfo array .
#|        -default value to return :-"name" ;;
#|      -frmN :-frame variable name .
#|        -if "now" is specified the curent frame will be returned if the
#|         _ trajectory is already loaded  .
#|        -default value to return :
#|          -the current frame if the trajectory is already loaded .
#|          -'now' if the trajectory has not been loaded into VMD .
#|          -the first frame of the specified fragId if the current frame
#|           _ is outsde the fragment's range ;;
#|      -frstN :-first frame variable name .
#|        -default value to return :-the value obtained from the trajFrag
#|         _specification, or "first" otherwise ;;
#|      -lstN :-last frame variable name .
#|        -if "last" is specified the last frame number is returned if the
#|         _ trajectory was already loaded .
#|        -default value to return :
#|          -the value obtained from the trajFrag lists according to the
#|           _ fragId specification .
#|          -the last frame of the specified molecule .
#|          -'last' if the trajectory has not been loaded into VMD ;;
#|      -stpN :-step (stride) variable name .
#|        -default value to return :-1 ;
#|      -updN :-update selection variable name .
#|        -default value to return :-0 ;;
#|      -ldstpN :-loadStep variable name .
#|        -default value to return :-'trajInfo' ;;
#|      -lblN :-label variable name .
#|        -default value to return :-the specified 'selId' ;;
#|      -descN :-varible name for the description text of the selId .
#|        -default value to return :-"" ;;;;
#|  -notes :
#|    -the default values will be more accurated if the trajectories are loaded
#|     _ before calling this proc .
#|    -new selInfo array key 'desc' is not managed by this proc yet ;;
proc getSelInfo {selId selN idN fragN frmN frstN lstN stpN updN ldstpN \
                                                                lblN descN} {
  global selInfo trajInfo
  upvar $selN sel
  upvar $idN id
  upvar $fragN frag
  upvar $frmN frm
  upvar $frstN frst
  upvar $lstN lst
  upvar $stpN stp
  upvar $updN upd
  upvar $ldstpN ldstp
  upvar $lblN lbl
  upvar $descN desc
  if {[info exists selInfo($selId,selTxt)]} {
    set sel $selInfo($selId,selTxt)} else {set sel "none"}
  if {[info exists selInfo($selId,molId)]} {
      if {$selInfo($selId,molId) == "top"} {
          if {[molinfo num] > 0} {set id [molinfo top]} else {set id "top"}
        } else {set id $selInfo($selId,molId)}
    } else {if {[molinfo num] > 0} {set id [molinfo top]} else {set id "top"}}
  if {[info exists selInfo($selId,fragId)]} {
      if {$selInfo($selId,fragId) == "name"} {
          if {$id != "top"} {
            set frag $trajInfo($id,name)} else {set frag "name"}
        } else {set frag $selInfo($selId,fragId)}
    } else {
      if {$id == "top"} {set frag "name"} else {set frag $trajInfo($id,name)}}
  if {[info exists selInfo($selId,frame)]} {
      if {$selInfo($selId,frame) == "now"} {
          if {[info exists trajInfo($id,name)]} {
              if {[molinfo $id get numframes] != 0} {
                  set frm [simTime [molinfo $id get frame] $id]
                } else {set frm "now"}
            } else {set frm "now"}
        } else {set frm $selInfo($selId,frame)}
    } else {
      if {[info exists trajInfo($id,name)]} {
          if {[getTrajProp "loaded" $id $frag]} {
            set frm [simTime [molinfo $id get frame] $id]
            if {[simFrag $frm $id [trajFragSpec $frag $id]] == -1} {
              set frm [getTrajProp "iniTime" $id $frag]}
          } else {set frm "now"}
        } else {set frm "now"}}
  if {[info exists selInfo($selId,first)]} {
      set frst $selInfo($selId,first)
      if {($frst == "first") || ($frst == "iniTime")} {
        set frst [getTrajProp "iniTime" $id $frag]
        if {($frst == "unk")||($frst == "")} {set frst "first"}
        }
    } else {
      if {$id == "top"} {set frst "first"} else {
        set frst [getTrajProp "iniTime" $id $frag]
        if {($frst == "unk")||($frst == "")} {set frst "first"}
        }
      }
  if {[info exists selInfo($selId,last)]} {
      if {$selInfo($selId,last) == "last"} {
          if {[info exists trajInfo($id,name)]} {
              set lst [getTrajProp "finTime" $id $frag]
                if {($lst == "unk") || ($lst == "")} {set lst "last"}
            } else {set lst "last"}
        } else {set lst $selInfo($selId,last)}
    } else {
      if {[info exists trajInfo($id,name)]} {
          set lst [getTrajProp "finTime" $id $frag]
          if {($lst == "unk") || ($lst == "")} {set lst "last"}
        } else {set lst "last"}
      }
  if {[info exists selInfo($selId,step)]} {
    set stp $selInfo($selId,step)} else {set stp 1}
  if {[info exists selInfo($selId,updateSel)]} {
    set upd $selInfo($selId,updateSel)} else {set upd 0}
  if {[info exists selInfo($selId,loadStep)]} {
    set ldstp $selInfo($selId,loadStep)} else {set ldstp "trajInfo"}
  if {[info exists selInfo($selId,label)]} {
    set lbl $selInfo($selId,label)} else {set lbl $selId}
  if {[info exists selInfo($selId,desc]} {
    set desc $selInfo($selId,desc)} else {set desc ""}
  }

#|-namespace eval trajSelId :
#|  -contains variables and procedures used to iterate along trajectory frames
#|   _ specified by a selId as an selInfo array key .
#|  -usage :
#|    -while {[trajSelId::iterate] <selId> <varArgs>]} { ... } :
#|      -the while loop will iterate the number once for each frame in the
#|       _ trajectory according to the selInfo specifications .
#|      -to access the current frame number or the equivalent simulation time
#|       _ value inside the while loop use commands [trajSelId::getFrame] and
#|       _ [trajSelId::getDatX] ;;
#|  -list of namespace variables :
#|    -selId :-selection Id array key to access the selInfo array .
#|      -identifies the user-defined selection (of frames) to go over ;
#|    -id :-VMD mol Id specified in the selId ;
#|    -loSt :-output stream for log messages .
#|      -default value :-stdout ;;
#|    -errorFlag :-if "1" no iteration will be done and iterate returns "0" ;
#|    -finishedFlag :-if "1" no iteration will be done and iterate returns "0" ;
#|    -loadTraj :-if "1" each trajFrag have to be loaded ;
#|    -frameCount :-frame iteration counter ;
#|    -xDatComm :-command used to calculate the X data value ;
#|    -fragIds :-list of fragIds considered ;
#|    -currFragInd :-index of the current fragment ;
#|    -currFrag :-fragName of the current fragment ;
#|    -currFrame :-current frame along the trajectory .
#|      -this will be consecutive within a traj fragment, but will change
#|       _ every time the current fragment changes ;
#|    -finFrame :-points to the last frame of the current trajFrag or to the
#|     _ last frame indicated in the selId ;
#|    -usrFinFrame :-points to the final frame corresponding to the "last"
#|     _ selInfo array key specified in the selId .
#|      -this has a value different from -1 only when the current fragment
#|       _ includes the indicated frame ;
#|    -iniTime :-simulation time corresponding to the first frame to consider ;
#|    -finTime :-simulation time corresponding to the last frame to consider ;
#|    -loadStep :-loadStep as indicated in the selId ;
#|    -keepFragIds :-list of traj fragments to be kept (avoid deleting them) ;
#|    -upd :-update otion in the selInfo array ;
#|    -step :-step option in the selInfo array .
#|      -affect the frequency and number of frames gone over ;
#|    -seqTime :-indicates that the traj is sequential in time .
#|      -if "0" (as in an equilibration) :
#|        -frame number is reported instead of time as X data .
#|        -No user-specified first and last times are considered ;
#|      -note that this value is only set as default in the namespace variable
#|       _ declaration, but is not default-reset in the init proc :
#|        -it is reset to 1 at the end of the iteration cycle ;;;
#|  -list of namespace procedures :
#|    -init :-initializes namespace varibles ;
#|    -changeFrag :-updates frame pointers according to a new traj fragment ;
#|    -iterate :-perform a iteration pointing to the next traj frame ;
#|    -setSeqTime :-sets sequential-time frags evaluation to use the sim time
#|     _ (if possible) or the frame number in the getDatX command ;
#|    -setKeepFragIds :-sets user-specified keepFragIds ;
#|    -getFrame :-returns the current frame ;
#|    -getDatX :-returns the value of the simTime or simFrame corresponding
#|     _ to the current frame ;
#|    -getErrorFlag :-returns the value of the "errorFlag" variable ;;;
namespace eval trajSelId {
  global trajInfo selInfo
  namespace export getFrame getDatX iterate getErrorFlag
  variable selId ""
  variable id -1
  variable loSt stdout
  variable errorFlag 0
  variable finishedFlag 0
  variable loadTraj 0
  variable frameCount 0
  variable xDatComm {simTime $currFrame $id}
  variable fragIds {}
  variable currFragInd 0
  variable currFrag ""
  variable currFrame -1
  variable finFrame -1
  variable usrFinFrame -1
  variable iniTime ""
  variable finTime ""
  variable loadStep "trajFrag"
  variable keepFragIds {}
  variable upd 0
  variable step 1
  variable seqTime 1

#|-proc trajSelId::init {elIdUsr {keepFragIdsUsr {}} {exFragIds {}}
#|                                                 _ {loStUsr stdout}} :
#|  -initializes most of the variables according to the user-specified selId .
#|  -notes :-the 'lbl' and 'desc' varaibles from getSelInfo is not used ;;
  proc init {selIdUsr {keepFragIdsUsr {}} {exFragIds {}} {loStUsr stdout}} {
    variable selId $selIdUsr
    variable id -1
    variable loSt $loStUsr
    variable errorFlag 0
    variable finishedFlag 0
    variable loadTraj 0
    variable frameCount 0
    variable xDatComm {simTime $currFrame $id}
    variable fragIds {}
    variable currFragInd 0
    variable currFrag ""
    variable currFrame 0
    variable finFrame -1
    variable usrFinFrame -1
    variable iniTime ""
    variable finTime ""
    variable loadStep "trajFrag"
    variable keepFragIds {}
    variable upd 0
    variable step 1
    variable seqTime
    if {$selId == ""} {return}
    getSelInfo $selId selTxt id frag frm iniTime finTime step upd loadStep \
                      lbl desc
    set keepFragIds [trajFragSpec $keepFragIdsUsr $id loSt $loSt]
    if {$id == "top"} {
      puts $loSt "Error: no loaded trajInfo"
      set errorFlag 1
      return
      }
    if {[getTrajProp "loaded" $id $frag exclude $exFragIds loSt $loSt]} {
      set loadTraj 0} else {set loadTraj 1}
    if {$seqTime} {
      set seqTime [getTrajProp "seqTime" $id $frag excl $exFragIds loSt $loSt]
      }
    if {!$seqTime} {
      set xDatComm {set frameCount}
      puts $loSt "Non-sequential time: using frame number instead."
      }
# setting up current fragment, current frame, and final frame
    set fragIds [trajFragSpec $frag $id exclude $exFragIds loSt $loSt]
    changeFrag $currFragInd
    }   ;# trajSelId::init

#|-proc changeFrag {fragInd} :
#|  -updates the pointers to initial and final frames and to fragments .
#|  -loads the updated traj fragment if necessary ;
  proc changeFrag {fragInd} {
    variable loadTraj
    variable id
    variable fragIds
    variable loadStep
    variable loSt
    variable currFragInd $fragInd
    variable currFrag
    variable iniTime
    variable finTime
    variable currFrame
    variable finFrame
    variable usrFinFrame
    variable seqTime
# seek the fragment containing the user-specified iniTime
    if {$seqTime} {
      for {set fragi $currFragInd} {$fragi < [llength $fragIds]} {incr fragi} {
        if {($iniTime>=[getTrajProp "iniTime" $id [lindex $fragIds $fragi]])&&\
            ($iniTime<=[getTrajProp "finTime" $id [lindex $fragIds $fragi]])} {
          set currFragInd $fragi; break}}}
    set currFrag [lindex $fragIds $currFragInd]
    if {$loadTraj} {trajLoad $id $currFrag loadStep $loadStep loSt $loSt}
    set currFrame [getTrajProp "iniFrame" $id $currFrag loSt $loSt]
    set finFrame [getTrajProp "finFrame" $id $currFrag loSt $loSt]
# correct the initial and final frames according to the user-specified selId
    if {$seqTime} {
      set usrIniFrame [simFrame $iniTime $id $currFrag]
      set usrFinFrame [simFrame $finTime $id $currFrag]
      if {$usrIniFrame != -1} {
        if {$currFrame < $usrIniFrame} {set currFrame $usrIniFrame}
        }
      if {$usrFinFrame != -1} {
        if {$finFrame > $usrFinFrame} {set finFrame $usrFinFrame}
        }
      }
    }   ;# changeFrag

#|-proc trajSel::iterate {selIdUsr args} :
#|  -increases the currFrame variable except if it is the first frame .
#|  -arguments :
#|    -selIdUsr :-key name to access the selInfo array .
#|      -array keys considered :
#|        -molId, fragId, first, last, step, and loadStep ;;
#|    -args (variable arguments) :
#|      -"keepFragId", "keep" :
#|        -fragId specification to avoid deleting specific traj fragments .
#|        -default value :-{} ;;
#|      -"exFragId", "exclude", "except", "excl" :
#|        -"exclude" fragId specification for the trajFragSpec proc .
#|        -default value :-{} ;;
#|      -"loSt", "channelId", "log" :-output stream for log messages .
#|        -default value :-stdout ;;;;
#|  -note :-not documented in detail yet ;;
  proc iterate {selIdUsr args} {
    variable selId
    variable id
    variable loSt
    variable step
    variable errorFlag
    variable finishedFlag
    variable loadTraj
    variable frameCount
    variable currFragInd
    variable currFrag
    variable currFrame
    variable finFrame
    variable fragIds
    variable usrFinFrame
    variable keepFragIds
# default values for arguments
  set loStUsr stdout; set keepFragIdUsr {}; set exFragId {}
# decode variable arguments
  if {[expr {[llength $args]%2}] == 0} {   ;# even or 0 optional arguments
    if {[llength $args] > 0} {
      foreach {arg val} $args {
        switch $arg {
          "keepFragId" - "keep" {set keepFragIdUsr $val}
          "exFragId" - "exclude" - "except" - "excl" {set exFragId $val}
          "loSt" -  "channelId" - "log" {set loStUsr $val}
          default {puts $loSt "trajSelId::iterate: argument unkown: $arg"}
          }
        }
      }
    } else {   ;# odd number of arguments
      puts $loSt "trajSelId::iterate: Odd number of arguments! args: $args"
      return ""
      }
    if {$errorFlag || $finishedFlag} {puts $loSt "Error Flag"; return 0}
    if {$selId != $selIdUsr}  {
      init $selIdUsr $keepFragIdUsr $exFragId $loStUsr
      return 1
      }
    incr currFrame $step
    incr frameCount
    if {$currFrame <= $finFrame} {   ;# running over the current frag
      return 1
    } else {   ;# end of the current frag exceeded
# delete the current (just completed) fragment if it was not previouly loaded
#  and it was not included in the keepFragIds list
      if {($loadTraj) && \
        ([lsearch $keepFragIds $currFrag] < 0)} {
          trajDelete $id $currFrag loSt $loSt
          }
      if {$usrFinFrame == -1} {
# the frag with the user finTime was not reached yet
        if {$currFragInd == [expr {[llength $fragIds] - 1}]} {
# no more fragments to load
          set seqTime 1
          set selId ""
          if {$loadTraj} {trajDelete $id $keepFragIds loSt $loSt}
          return 0
        } else {
# load the next fragment
          changeFrag [expr {$currFragInd + 1}]
          return 1
          }
      } else {
# the current frag contains the user-specified finTime
        set seqTime 1
        set selId ""
        if {$loadTraj} {trajDelete $id $keepFragIds loSt $loSt}
        return 0
        }
      }
    }   ;# trajSelId::iterate

#|-proc setSeqTime {val} :
#|  -sets seqTime usage for getDatX to report frame numbers instead of
#|   _ simulation time if val is "0" ;
  proc setSeqTime {val} {
    variable seqTime $val
    }

#|-proc trajSelId::getFrame {} :
#|  -returns the current frame ;
  proc getFrame {} {
    variable currFrame
    return $currFrame
    }

#|-proc trajSelId::getDatX {} :
#|  -returns the current simTime or simFrame in the trajectory ;
  proc getDatX {} {
    variable xDatComm
    variable id
    variable currFrame
    variable frameCount
    return [eval $xDatComm]
    }

#|-proc trajSelId::setKeepFragIds {l_frag} :
#|  -sets the keepFragIds variable .
#|  -used when a particular fragment or frame must be loaded during the whole
#|   _ iteration process (i.e. a reference frame for analysis
#|   _ of a long trajectory comprised of several fragments) ;
  proc setKeepFragIds {l_frag} {
    variable keepFragIds $l_frag
#    puts $loSt "traj fragments to be kept: $keepFragIds"
    }

#|-proc trajSelId::getErrorFlag {} :
#|  -returns the value of the "errorFlag" variable ;
  proc getErrorFlag {} {
    variable errorFlag
    return $errorFlag
    }   ;# trajSelId::getErrorFlag

  }   ;# namespace trajSelId

proc testNS {selId} {
  namespace import trajSelId::getFrame trajSelId::getDatX
  puts "testing ::trajSelId:: selId: $selId"
  puts "current namespace: [namespace current]"
  puts "  going over all frames..."
  while {[trajSelId::iterate $selId keep iniProdSim]} {
    puts "frame: [getFrame]   xDat: [getDatX]"
    }
  puts "Error flag: [trajSelId::getErrorFlag]"
  }


#|-proc simTime {frm {id "top"}} :
#|  -Returns the corresponding time (in ns) of a frame in a trajectory .
#|  -if the trajectory is was not previously loaded returns -1 .
#|  -note that it calculates the trajectory length and the number of frames
#|   _ each time the procedure is called which could not be the ideal .
#|  -arguments :
#|    -frm :-frame number .
#|      -acceptable values :
#|        - "now" :-the current frame is used to determine the sim time ;;;
#|    -id :-Id if the vmd trajectory included in trajInfo array .
#|      -the value "top" may be specified to use the top molecule ;;;
proc simTime {frm {id "top"}} {
  global trajInfo ind
  if {$id == "top"} {set id [molinfo top]}
  if {$frm == "now"} {set frm [molinfo $id get frame]}
  set numFrames [molinfo $id get numframes]
  if {$numFrames == 0} {return -1}
  if {$frm >= $numFrames} {
    return -1
#    set frm [expr {[molinfo $id get numframes] - 1}]
    }
# searches the l_trajFrag that includes the indicated frame
  foreach l_trajFrag $trajInfo($id,trajFrag) {
    set iniFrame [lindex $l_trajFrag $ind(iniFrame)]
    set finFrame [lindex $l_trajFrag $ind(finFrame)]
    if {$iniFrame == "unk"} {continue}
    if {($frm >= $iniFrame) && ($frm <= $finFrame)} {break}
    }
# calculates the simulation time
  set iniTime [lindex $l_trajFrag $ind(iniTime)]
  set frameTime [lindex $l_trajFrag $ind(frameTime)]
  return [expr {$iniTime + $frameTime*($frm - $iniFrame)}]
  }

#|-proc simFrame {nsTime {id "top"} {fragId "name"}} :
#|  -returns the frame number corresponding to a time in ns for a simulation .
#|  -the result will be transformed to an integer .
#|  -if the result exeed the final frame of the specified traj frag the last
#|   _ frame of that fragment is returned (error for rounding) :
#|    -the behavior must be tested more extensively ;
#|  -arguments :
#|    -nsTime :-time in ns corresponding the the frame requested ;
#|    -id :-Id of the vmd trajectory included in trajInfo array .
#|      -the value "top" may be specified to use the top molecule ;
#|    -fragId :-specifies the traj fragments to be considered .
#|      -acceptable values :
#|        -"name" :
#|          -this is the default value .
#|          -the name of the simulation is used (from trajInfo(id,name)) .
#|          -this makes the program consider the last simName which
#|           _ generally corresponds to the production simulation ;
#|        -a fragName or simName included in the tragFrag lists ;;;
#|  -notes :
#|    -the requested simTime may be included in several fragments, but only
#|     _ the last occurrence in the trajFragments is considered .
#|    -trajFragSpec may be used, but this may be affect performance ;;
proc simFrame {nsTime {id "top"} {fragId "name"}} {
  global trajInfo ind
  if {$id == "top"} {set id [molinfo top]}
  set numFrames [molinfo $id get numframes]
  if {$numFrames == 0} {return -1}
  if {$fragId == "name"} {set fragId $trajInfo($id,name)}
#  set fragId [trajFragSpec $fragId $id]
  set numFrag [llength $trajInfo($id,trajFrag)]
#  set finTimeLast [lindex $trajInfo($id,trajFrag) end $ind(finTime)]
#  if {$finTimeLast > $nsTime} {
#    return -1
#    set nsTime $finTimeLast
#    }
# searches for the trajFrag where the specified simulation time is included
  for {set tfi [expr {$numFrag - 1}]} {$tfi >= 0} {incr tfi -1} {
    set l_trajFrag [lindex $trajInfo($id,trajFrag) $tfi]
    if {($fragId == [lindex $l_trajFrag $ind(fragName)]) || \
        ($fragId == [lindex $l_trajFrag $ind(simName)])} {
      set iniTime [lindex $l_trajFrag $ind(iniTime)]
      set finTime [lindex $l_trajFrag $ind(finTime)]
      if {($nsTime >= $iniTime) && ($nsTime <= $finTime)} {break}
      }
    }
  if {$tfi == -1} {return -1}
  set iniFrame [lindex $l_trajFrag $ind(iniFrame)]
  if {$iniFrame == "unk"} {return -1}
  set frameTime [lindex $l_trajFrag $ind(frameTime)]
  set frame [expr {round($iniFrame + ($nsTime - $iniTime)/$frameTime)}]
  if {$frame > [getTrajProp "finFrame" $id $fragId]} {
    set frame [getTrajProp "finFrame" $id $fragId]}   ;# to avoid rounding error
# note : 
#  return [expr {int($iniFrame + ($nsTime - $iniTime)/$frameTime)}]
  return $frame
  }

#|-proc simFrag {nsTime {id "top"} {fragId "name"}} :
#|  -returns the fragName of the fragment containing a specific simulation
#|   _ time (in ns) considering a list of fragIds specifications .
#|  -returns -1 id the time is not included in the fragId specification .
#|  -arguments :
#|    -nsTime :-simulation time in nano secounds to search for .
#|      -acceptable values :
#|      -"now" :-the current frame is used to determine the sim time ;;;
#|    -id :-mol Id of the trajectory considered in the trajInfo array ;
#|    -fragId :-list of fragment specification to be considered in the search :
#|      -value "name" (default) may be used to consider the sim name in
#|       _ trajInfo(id,name) value ;;
#|   -NOTE :
#|     -it seems neccesary to preprocess fragId with trajFragSpec
#|      _ before calling this proc.) .
#|     -has to be considered to include trajFragSpec within this proc ;;;
proc simFrag {nsTime {id "top"} {fragId "name"}} {
  global trajInfo ind
  if {$id == "top"} {set id [molinfo top]}
  if {$fragId == "name"} {set fragId $trajInfo($id,name)}
  if {$nsTime == "now"} {set nsTime [simTime [molinfo $id get frame] $id]}
  set fragName "-1"
  set numFrag [llength $trajInfo($id,trajFrag)]
  # searches for the trajFrag where the specified simulation time is included
  foreach frag $fragId {
    for {set tfi [expr {$numFrag - 1}]} {$tfi >= 0} {incr tfi -1} {
    set l_trajFrag [lindex $trajInfo($id,trajFrag) $tfi]
      if {($frag == [lindex $l_trajFrag $ind(fragName)]) || \
          ($frag == [lindex $l_trajFrag $ind(simName)])} {
        set iniTime [lindex $l_trajFrag $ind(iniTime)]
        set finTime [lindex $l_trajFrag $ind(finTime)]
        if {($nsTime >= $iniTime) && ($nsTime <= $finTime)} {
          set fragName [lindex $l_trajFrag $ind(fragName)]
          break
          }
        }
      }
    if {$fragName != "-1"} {break}
    }
  return $fragName
  }   ;# simFrag



